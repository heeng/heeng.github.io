<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    阿里实习生面经 |  岛
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  
  <canvas width="1777" height="841" style="position: fixed; left: 0px; top: 0px; z-index: 999; pointer-events: none;"></canvas>
  
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-阿里五轮面试面经" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  阿里实习生面经
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/28/%E9%98%BF%E9%87%8C%E4%BA%94%E8%BD%AE%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" class="article-date">
  <time datetime="2020-05-28T07:09:45.082Z" itemprop="datePublished">2020-05-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/source/categories/%E9%9D%A2%E7%BB%8F/">面经</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">25 分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="HashMap-Java7-8源码详解"><a href="#HashMap-Java7-8源码详解" class="headerlink" title="HashMap Java7/8源码详解"></a>HashMap Java7/8源码详解</h2><p><strong>1、HashMap与哈希表</strong><br>数据结构：哈希桶，底层是数组，查找速度很快o(1)<br>哈希表的软肋：数据的碰撞，解决碰撞，就是用链表<br>哈希表的核心是基于哈希值的桶和链表<br>O(1)的平均查找、插入、删除时间<br>致命缺陷是哈希值的碰撞<br><strong>2、Java7 HashMap</strong><br>经典的Hash表实现：数组+链表<br>重要知识点：<br>初始容量：16,2的幂次方<br>负载因子：0.75<br>哈希算法<br>扩容<br> 低效<br> 线程不安全</p>
<p><strong>3、为什么一定要是2的幂次方</strong><br>hash&amp;(length-1)<br>只有在长度为2的幂次方时，对他进行减一操作时才能拿到全是1的值，然后用位运算的方式快速的拿到数组的下标，并且他的分布还是均匀的</p>
<p><strong>4、Java7的HashMap容易遇到的问题</strong><br>死锁<br>环形链表<br>链接: <a href="https://coolshell.cn/articles/9606.html/" target="_blank" rel="noopener">link</a>.</p>
<p>可以通过精心构造的恶意请求引发Dos<br>链表性能退化分析</p>
<p><strong>5、Java8 HashMap的改进</strong><br>数组+链表/红黑树<br>扩容时插入顺序的改进<br>函数方法<br>    forEach<br>    compute系列<br>Map的新API<br>    merge<br>    replace</p>
<h2 id="阿里五轮面试面经"><a href="#阿里五轮面试面经" class="headerlink" title="阿里五轮面试面经"></a>阿里五轮面试面经</h2><p><strong>1、Synchronized和lock锁的区别；看过synchronized源码吗？</strong></p>
<p>synchronized底层语义原理<br>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。<br>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72828483</a>.</p>
<p><strong>2、JVM自动内存管理，Minor GC与Full GC的触发机制</strong><br>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://blog.csdn.net/ysl19910806/article/details/99776387</a>.</p>
<p><strong>3、了解过JVM调优没，基本思路是什么</strong><br>如果CPU使用率较高，GC频繁且GC时间长，可能就需要JVM调优了。<br>基本思路就是让每一次GC都回收尽可能多的对象，<br>对于CMS来说，要合理设置年轻代和年老代的大小。该如何确定它们的大小呢？这是一个迭代的过程，可以先采用JVM的默认值，然后通过压测分析GC日志。</p>
<p>如果看年轻代的内存使用率处在高位，导致频繁的Minor GC，而频繁GC的效率又不高，说明对象没那么快能被回收，这时年轻代可以适当调大一点。</p>
<p>如果看年老代的内存使用率处在高位，导致频繁的Full GC，这样分两种情况：如果每次Full GC后年老代的内存占用率没有下来，可以怀疑是内存泄漏；如果Full GC后年老代的内存占用率下来了，说明不是内存泄漏，要考虑调大年老代。</p>
<p>对于G1收集器来说，可以适当调大Java堆，因为G1收集器采用了局部区域收集策略，单次垃圾收集的时间可控，可以管理较大的Java堆。</p>
<p><strong>4、如何设计存储海量数据的存储系统</strong></p>
<p>海量数据的解决方案：<br>页面上：<br>使用缓存；页面静态化技术；<br>数据库层面：<br>分离数据库中活跃的数据；批量读取和延迟修改；读写分离；使用NoSQL和Hadoop等技术；分布式部署数据库；应用服务和数据服务分离；<br>其他方面：<br>使用搜索引擎搜索数据库中的数据；进行业务的拆分；<br>高并发情况下的解决方案：<br>应用程序和静态资源文件进行分离，静态资源可以使用CDN；<br>集群与分布式；<br>使用Nginx反向代理；</p>
<p><strong>5、缓存的实现原理，设计缓存要注意什么</strong><br>将热点数据放在内存中，用户查询时命中内存中的数据而不用到数据库中查询<br>注意缓存的一致性，缓存雪崩、击穿、穿透的问题</p>
<p><strong>6、volatile关键字的如何保证内存可见性</strong><br>volatile修饰的变量保证其每个写操作后都更新到主内存，每个读操作都到主内存中更新，具体的话是在JVM层面，在修饰的变量前后加关键字<br>顺带一提volatile还能防止指令重排，这两者的实现方式都是内存屏障。</p>
<p>happen-before原则<br>如果前一个操作的执行结果必须对后一个操作可见，那就不允许这两个操作进行重排序，且happen-befor具有传递性</p>
<p><strong>7、你说你熟悉并发编程，那么你说说Java锁有哪些种类，以及区别</strong>（果然深度不一样）<br>公平锁/非公平锁<br>这个是在ReentrankLock中实现的，synchronized没有，是用一个队列实现的，在公平锁好理解，就是先进这个队列的，也先出队列获得资源，而非公平锁的话，则是还没有进队列之前可以与队列中的线程竞争尝试获得锁，如果获取失败，则进队列，此时也是要乖乖等前面出队才行<br>可重入锁<br>如果一个线程获得过该锁，可以再次获得，主要是用途就是在递归方面，还有就是防止死锁，比如在一个同步方法块中调用了另一个相同锁对象的同步方法块<br>独享锁/共享锁<br>共享锁可以由多个线程获取使用，而独享锁只能由一个线程获取。<br>对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁<br>读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。其中获得写锁的线程还能同时获得读锁，然后通过释放写锁来降级。读锁则不能升级<br>互斥锁/读写锁<br>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。<br>互斥锁在Java中的具体实现就是ReentrantLock<br>读写锁在Java中的具体实现就是ReadWriteLock<br>乐观锁/悲观锁<br>乐观锁就是乐观的认为不会发生冲突，用cas和版本号实现<br>悲观锁就是认为一定会发生冲突，对操作上锁<br>分段锁<br>在1.7的concurrenthashmap中有分段锁的实现，具体为默认16个的segement数组，其中segement继承自reentranklock，每个线程过来获取一个锁，然后操作这个锁下连着的map。<br>偏向锁/轻量级锁/重量级锁<br>在jdk1.6中做了第synchronized的优化，<br>偏向锁指的是当前只有这个线程获得，没有发生争抢，此时将方法头的markword设置成0，然后每次过来都cas一下就好，不用重复的获取锁<br>轻量级锁：在偏向锁的基础上，有线程来争抢，此时膨胀为轻量级锁，多个线程获取锁时用cas自旋获取，而不是阻塞状态<br>重量级锁：轻量级锁自旋一定次数后，膨胀为重量级锁，其他线程阻塞，当获取锁线程释放锁后唤醒其他线程。（线程阻塞和唤醒比上下文切换的时间影响大的多，涉及到用户态和内核态的切换）<br>自旋锁：在没有获取锁的时候，不挂起而是不断轮询锁的状态</p>
<p><strong>8、Http请求的过程与原理</strong></p>
<p><strong>9、对Java中的对象、实例、句柄、直接指针的理解</strong><br>虚拟机在创建对象的时候，会优先查询常量池中是否有该对象的实例，如果没有则需要加载、解析、初始化class，然后分配内存，初始化内存，设置对象（HASH CODE 、 GC年代等），最后执行init才算是创建完对象。<br>        对象即实例。<br>        String str；<br>        以上的str就是一个句柄，但是并没有指向任何对象，好比这是一个客服中心，告诉你打400号码联系客服中心，但是没有指明是哪个客服人员，如果String str = “9527”;这个时候就是说明了编号9527为您服务，可以通过句柄访问对象。<br>直接指针，我理解的：<br>        class Test{<br>            public void doSth();<br>        }<br>        new Test().doSth();//直接指针<br>        Test() test = new Test();//句柄引用<br>        test.doSth();<br>        当然直接指针肯定是速度更快的，但是如果用句柄，对象被移动（比如GC），只需要改变指针而不会改变引用；如果是直接指针的方式，速度那是杠杠的，不用多余的一次指针的定位。综上，写JVM多用直接指针，写应用更多的是句柄。</p>
<p><strong>10、什么是SQL注入？如何防范sql注入？</strong><br>防治SQL注入式攻击可以采用两种方法，一是加强对用户输入内容的检查与验证;二是强迫使用参数化语句来传递用户输入的内容。<br>SQL注入并不是一个在SQL内不可解决的问题，这种攻击方式的存在也不能完全归咎于SQL这种语言，因为注入的问题而放弃SQL这种方式也是因噎废食。首先先说一个我在其他回答中也曾提到过的观点：没有（运行时）编译，就没有注入。<br>SQL注入产生的原因，和栈溢出、XSS等很多其他的攻击方法类似，就是未经检查或者未经充分检查的用户输入数据，意外变成了代码被执行。针对于SQL注入，则是用户提交的数据，被数据库系统编译而产生了开发者预期之外的动作。也就是，SQL注入是用户输入的数据，在拼接SQL语句的过程中，超越了数据本身，成为了SQL语句查询逻辑的一部分，然后这样被拼接出来的SQL语句被数据库执行，产生了开发者预期之外的动作。所以从根本上防止上述类型攻击的手段，还是避免数据变成代码被执行，时刻分清代码和数据的界限。而具体到SQL注入来说，被执行的恶意代码是通过数据库的SQL解释引擎编译得到的，所以只要避免用户输入的数据被数据库系统编译就可以了。现在的数据库系统都提供SQL语句的预编译（prepare）和查询参数绑定功能，在SQL语句中放置占位符’?’，然后将带有占位符的SQL语句传给数据库编译，执行的时候才将用户输入的数据作为执行的参数传给用户。这样的操作不仅使得SQL语句在书写的时候不再需要拼接，看起来也更直接，而且用户输入的数据也没有机会被送到数据库的SQL解释器被编译执行，也不会越权变成代码。至于为什么这种参数化的查询方式没有作为默认的使用方式，我想除了兼容老系统以外，直接使用SQL确实方便并且也有确定的使用场合。多说一点，从代码的角度来看，拼接SQL语句的做法也是不恰当的。<br>SQL注入#和$区别与总结：</p>
<p>1.#{}  将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。<br>如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by “111”,<br>如果传入的值是id，则解析成的sql为order by “id”.<br>2.$将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id,<br>如果传入的值是id，则解析成的sql为order by id.<br>3.#{}方式能够很大程度防止sql注入。<br>4.$方式无法防止Sql注入。<br>5.$方式一般用于传入数据库对象，例如传入表名.<br>6.一般能用#的就别用$.</p>
<p>MyBatis排序时使用order by 动态参数时需要注意，用$而不是#</p>
<p>Nosql数据库：<br>现在主流常用的数据库应该是redis和mongodb；<br>Redis<br>Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。目前由VMware主持开发工作。</p>
<ol>
<li>特点</li>
<li>1 数据格式<br>Redis 通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash/Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)五种类型，操作非常方便。比如，如果你在做好友系统，查看自己的好友关系，如果采用其他的key-value系统，则必须把对应的好友拼接成字符串，然后在提取好友时，再把value进行解析，而redis则相对简单，直接支持list的存储(采用双向链表或者压缩链表的存储方式)。<br>我们来看下这五种数据类型。<br>⑴ String<br>string 是 Redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个key对应一个value。<br>string 类型是二进制安全的。意思是 Redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象 。<br>string 类型是 Redis 最基本的数据类型，一个键最大能存储512MB。<br>⑵ Hash<br>Redis hash 是一个键值对集合。<br>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。<br>⑶ List<br>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>⑷ Sets<br>Redis的Set是string类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。<br>添加一个string元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回0，key对应的set不存在返回错误<br>⑸ sorted sets/zset<br>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。可以通过 zadd 命令（格式如下） 添加元素到集合，若元素在集合中存在则更新对应score。</li>
<li>优缺点<br>优势</li>
<li>非常丰富的数据结构；</li>
<li>Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断；</li>
<li>数据存在内存中，读写非常的高速，可以达到10w/s的频率。<br>缺点</li>
<li>Redis3.0后才出来官方的集群方案，但仍存在一些架构上的问题（出处）；</li>
<li>持久化功能体验不佳——通过快照方法实现的话，需要每隔一段时间将整个数据库的数据写到磁盘上，代价非常高；而aof方法只追踪变化的数据，类似于mysql的binlog方法，但追加log可能过大，同时所有操作均要重新执行一遍，恢复速度慢；</li>
<li>由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。<br>适用场景<br>适用于数据变化快且数据库大小可遇见（适合内存容量）的应用程序</li>
</ol>
<p>关系型数据库和非关系型数据库：<br>1.关系型数据库通过外键关联来建立表与表之间的关系，<br>2.非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。<br>3.非关系型数据库中，我们查询一条数据，结果出来一个数组，关系型数据库中，查询一条数据结果是一个对象。</p>
<p><strong>11、联合索引是什么</strong><br>对多个字段同时建立的索引(有顺序，ABC，ACB是完全不同的两种联合索引。)<br>为什么要用<br>以联合索引(a,b,c)为例</p>
<p>建立这样的索引相当于建立了索引a、ab、abc三个索引。一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。<br>覆盖(动词)索引。同样的有联合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=xxx and b = xxx。那么MySQL可以直接通过遍历索引取得数据，而无需读表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一<br>索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W<em>10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w <em>10% *10% *10%=1w，然后再排序、分页，哪个更高效，一眼便知<br>使用时注意什么<br>单个索引需要注意的事项，组合索引全部通用。比如索引列不要参与计算啊、or的两侧要么都索引列，要么都不是索引列啊、模糊匹配的时候%不要在头部啦等等<br>最左匹配原则。(A,B,C) 这样3列，mysql会首先匹配A，然后再B，C.<br>如果用(B,C)这样的数据来检索的话，就会找不到A使得索引失效。如果使用(A,C)这样的数据来检索的话，就会先找到所有A的值然后匹配C，此时联合索引是失效的。<br>把最常用的，筛选数据最多的字段放在左侧<br>多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上！ 但多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费一定搜索效率，故如果只有多条件联合查询时最好建联合索引！<br>联合索引本质：<br>当创建</em></em>(a,b,c)联合索引时，相当于创建了(a)单列索引<strong>，(a,b)联合索引以及</strong>(a,b,c)联合索引**<br>想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！<br>注：这个可以结合上边的 通俗理解 来思考！</p>
<p>MyISAM和InnoDB索引：<br>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。<br> InnoDB索引和MyISAM索引的区别：<br>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。<br>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别</p>
<p>MYSQL索引：<br>聚集索引和非聚集索引<br>Mysql索引类型：唯一索引、聚集索引、非聚集索引、全文索引<br>聚集索引：数据行的物理顺序和列值得逻辑顺序相同，一个表中只能拥有一个聚集索引。索引的叶子节点就是对应的数据节点，可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询。查询方面，聚集索引的速度往往更占优势。<br>非聚集索引：<br>该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块。<br>解决非聚集索引的二次查询问题：复合索引。需要按组最左侧索引的原则</p>
<p>磁盘IO操作包括三个参数：平均寻址时间、盘片旋转速度以及最大传输速度<br>最耗时的是寻找扇区的时候。</p>
<p><strong>12、网络协议层相关</strong><br>计算机网络分层：（TCP/IP分层）<br>OSI七层：<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<p>TCP/IP四层：<br>应用层、传输层、网络层、数据链路层<br><img src="https://img-blog.csdnimg.cn/20200415105525685.png" alt="在这里插入图片描述"><br>TCP和UDP属于传输层：<br>UDP：无连接，不可靠，可能出现丢包，顺序会乱，数据报模式，面对报文，不会占用太多系统资源。UDP首部结构简单，开销8个字节<br>UDP要实现可靠性，模拟TCP，但是无法在传输层保证数据的可靠传输，需要通过应用层来实现和控制。不考虑拥塞处理，可靠UDP设计：<br>1、    添加seq/ack机制，确保数据发送到对端<br>2、    添加发送和接受缓冲区，主要是用户超时重传<br>3、    添加超时重传机制<br>也有开源程序利用UDP实现了可靠的数据传输。分别为RUDP、RTP、UDT<br>TCP如何实现可靠性传输：<br>确认机制、重传机制、滑动窗口</p>
<p>TCP：面向连接的，可靠，编号，流量控制和拥塞控制，避免丢包，超时，重传，流模式，面对字节，会对字节信息进行处理，占用资源多。TCP首部复杂，开销至少25个字节。</p>
<p>TCP三次握手和四次挥手：<br>三次握手：<br>客户端像服务端发送SYN  seq<br>SYN:同步   seq：序列号<br>服务端像客户端回消息  seq  ACK（ACK=SYN+1）确保是这次连接<br>客户端设置seq   ACK<br>假如是两次握手，如果出现了客户端项服务的发送连接，但是因为网络延迟的原因没有连接成功，于是第二次发生连接，成功连接，然后第一次的连接服务端收到了，建立连接，这个连接在服务端就会一直等待客户端的数据交互，但是客户端以为这次连接失败了，让服务端浪费很多资源<br>四次挥手：<br>客户端向服务端发送FIN+ACK<br>服务端收到后发送ACK<br>服务端继续发送ACK确认（两次发送之间传递服务器未传输完成的数据）<br>客户端收到后发送ACK，之后饿虎的进入TIME-WAIT状态，两个MSL时间后无响应则连接关闭。MSL:最大分节生命期<br>如果三次挥手，那么不能确定数据传输完成就关闭连接了。</p>
<p>DNS域名解析：<br>首先在本地DNS服务器中找是否有缓存，没有的话就找  根DNS服务器—顶级域DNS服务器—权威DNS服务器—查询到IP地址，回送到浏览器（递归查询和迭代查询）<br>浏览器获得IP地址之后，发起三次握手<br>TCP/IP建立连接之后，浏览器就可以向服务器发送请求了<br>服务器接受到请求之后，根据路径参数，经过处理，生成HTML页面代码返回给浏览器；<br>浏览器拿到代码之后，进行解析和渲染。</p>
<p>DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。<br>DNS区域传输的时候使用TCP协议：<br>1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。<br>2.TCP是一种可靠连接，保证了数据的准确性。<br>域名解析时使用UDP协议：<br>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包</p>
<p><strong>13、携程面经：</strong><br>1、    链表的定义<br>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://blog.csdn.net/m0_37631322/article/details/81777855</a>.</p>
<p>扩展：约瑟环的实现，用队列实现<br>2、    实现链表翻转<br>3、    怎么判断链表是否有环<br>4、    二叉平衡树如何用一维数组存储<br>5、    JVM分区<br>五大分区：<br>线程私有：<br>        程序计数器、虚拟机栈、本地方法栈<br>线程共有：<br>    堆、方法区<br>6、JVM GC<br>7、求数组的最大子序列和<br>8、final关键字4种方法<br>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.cnblogs.com/jiejunwang/p/10285979.html</a>.</p>
<p>9、继承、封装和多态<br>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.cnblogs.com/yinbiao/p/8067273.html</a>.</p>
<p>10、sleep用法<br>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://blog.csdn.net/xzj80927/article/details/84590610</a>.</p>
<p>11、线程池<br>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.jianshu.com/p/210eab345423</a>.</p>
<p>12、spring ioc aop 概述和优点<br>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://blog.csdn.net/dkbnull/article/details/87219562</a>.</p>
<p><a href="https://www.job592.com/pay/comms11116.html" target="_blank" rel="noopener">https://www.job592.com/pay/comms11116.html</a><br><a href="http://www.mybbchina.net/jingli/148728.html" target="_blank" rel="noopener">http://www.mybbchina.net/jingli/148728.html</a></p>
<p><strong>14.服务器如何记录用户的状态（cookie和session）</strong></p>
<p><strong>15、负载均衡</strong></p>
<p>链接: <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://blog.csdn.net/bpb_cx/article/details/82771168</a>.</p>
<p><strong>16、面向对象和面向过程</strong></p>
<p>面向过程：</p>
<p>　　　　优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>　　　　缺点：没有面向对象易维护、易复用、易扩展<br>面向对象：</p>
<p>　　　　优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护<br>　　　　缺点：性能比面向过程低<br>　　　　<br><strong>17、如果硬件和带宽不变，如何提高TCP传输速度</strong><br>用UDP实现，然后自己实现可靠性</p>
<p><strong>18、一、fork入门知识</strong></p>
<pre><code>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</code></pre><p>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。<br>为什么两个进程的fpid不同呢，这与fork函数的特性有关。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：<br>    1）在父进程中，fork返回新创建子进程的进程ID；<br>    2）在子进程中，fork返回0；<br>    3）如果出现错误，fork返回一个负值；</p>
<pre><code>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</code></pre>
      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong>
              本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://github.com/heeng/heeng.github.io/2020/05/28/%E9%98%BF%E9%87%8C%E4%BA%94%E8%BD%AE%E9%9D%A2%E8%AF%95%E9%9D%A2%E7%BB%8F/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/" rel="tag">实习面经</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/05/28/2020%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            华为成渝地区实习生面经
          
        </div>
      </a>
    
    
      <a href="/2020/05/28/%E5%A6%82%E6%9E%9C%E6%98%AFMysql%E5%BC%95%E8%B5%B7%E7%9A%84CPU%E6%B6%88%E8%80%97%E8%BF%87%E5%A4%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Mysql引起的CPU消耗过大，如何优化？</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: 'DhhLYNK1QkBKND9ATnBnj05o-gzGzoHsz',
        app_key: 'gMdjqqGHefDaODSMNnVWAs4f',
        path: window.location.pathname,
        notify: false,
        verify: false,
        avatar: 'monsterid',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> 衡一嘉
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="岛"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechatpay.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->


<script src="/js/clickLove.js"></script>


<!-- ClickBoom -->


<script src="/js/clickBoom.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
</body>

</html>